{"ast":null,"code":"// import React, { useEffect, useRef, useState } from 'react';\n\n// export default function DrawingCanvas({ socket, roomId, myColorRef }){\n//   const canvasRef = useRef();\n//   const [isDrawing, setIsDrawing] = useState(false);\n//   const [color, setColor] = useState('#000000');\n//   const [width, setWidth] = useState(2);\n//   const pathRef = useRef([]);\n\n//   useEffect(()=>{\n//     const c = canvasRef.current;\n//     const ctx = c.getContext('2d');\n//     const onLoadCommands = (commands)=>{\n//       commands.forEach(cmd=>{\n//         if(cmd.type === 'stroke'){\n//           drawStroke(ctx, cmd.data, false);\n//         }else if(cmd.type === 'clear'){\n//           ctx.clearRect(0,0,c.width,c.height);\n//         }\n//       });\n//     };\n//     if(socket){\n//       socket.on('load-commands', onLoadCommands);\n//       socket.on('draw-start', ({ payload })=>{\n//         beginRemoteStroke(ctx, payload);\n//       });\n//       socket.on('draw-move', ({ payload })=>{\n//         moveRemoteStroke(ctx, payload);\n//       });\n//       socket.on('draw-end', ({ command })=>{\n//         endRemoteStroke(ctx, command);\n//       });\n//       socket.on('clear-canvas', ()=>{ ctx.clearRect(0,0,c.width,c.height); });\n//     }\n//     return ()=>{\n//       if(socket){\n//         socket.off('load-commands', onLoadCommands);\n//       }\n//     };\n//   }, [socket]);\n\n//   function drawStroke(ctx, data, smooth=true){\n//     ctx.lineJoin = 'round'; ctx.lineCap = 'round';\n//     ctx.strokeStyle = data.color; ctx.lineWidth = data.width;\n//     ctx.beginPath();\n//     const path = data.path || [];\n//     if(path.length===0) return;\n//     ctx.moveTo(path[0].x, path[0].y);\n//     for(let i=1;i<path.length;i++){ ctx.lineTo(path[i].x, path[i].y); }\n//     ctx.stroke();\n//   }\n\n//   function beginRemoteStroke(ctx, payload){ drawStroke(ctx, { color: payload.color, width: payload.width, path: [payload.point] }, false); }\n//   function moveRemoteStroke(ctx, payload){ drawStroke(ctx, { color: payload.color, width: payload.width, path: payload.path }, false); }\n//   function endRemoteStroke(ctx, command){ drawStroke(ctx, command.data, false); }\n\n//   function getPos(e){\n//     const rect = canvasRef.current.getBoundingClientRect();\n//     const clientX = e.touches ? e.touches[0].clientX : e.clientX;\n//     const clientY = e.touches ? e.touches[0].clientY : e.clientY;\n//     return { x: clientX - rect.left, y: clientY - rect.top };\n//   }\n\n//   function start(e){\n//     if(!socket) return;\n//     const p = getPos(e);\n//     setIsDrawing(true);\n//     pathRef.current = [p];\n//     socket.emit('draw-start', { roomId, payload: { point: p, color, width } });\n//   }\n//   function draw(e){\n//     if(!isDrawing || !socket) return;\n//     const p = getPos(e);\n//     pathRef.current.push(p);\n//     socket.emit('draw-move', { roomId, payload: { path: [p], color, width } });\n//     const ctx = canvasRef.current.getContext('2d');\n//     drawStroke(ctx, { color, width, path: pathRef.current });\n//     socket.emit('cursor-move', { roomId, x: p.x, y: p.y });\n//   }\n//   function end(e){\n//     if(!isDrawing || !socket) return;\n//     setIsDrawing(false);\n//     const command = { type:'stroke', data: { path: pathRef.current, color, width }, timestamp: new Date() };\n//     socket.emit('draw-end', { roomId, command });\n//     pathRef.current = [];\n//   }\n\n//   function clearCanvas(){\n//     const ctx = canvasRef.current.getContext('2d');\n//     ctx.clearRect(0,0,canvasRef.current.width, canvasRef.current.height);\n//     if(socket) socket.emit('clear-canvas', { roomId });\n//   }\n\n//   return (\n//     <div style={{width:'100%', height:'100%'}} onMouseLeave={()=>{ if(socket) socket.emit('cursor-move', { roomId, x:-1, y:-1 }); }}>\n//       <canvas ref={canvasRef} style={{width:'100%', height:'100%'}} onMouseDown={start} onMouseMove={draw} onMouseUp={end}\n//         onTouchStart={start} onTouchMove={draw} onTouchEnd={end} />\n//       <div style={{position:'absolute',left:8,top:8,background:'rgba(255,255,255,0.9)',padding:8,borderRadius:6}}>\n//         <div>Color: <input type=\"color\" value={color} onChange={e=>setColor(e.target.value)} /></div>\n//         <div>Width: <input className=\"slider\" type=\"range\" min=\"1\" max=\"12\" value={width} onChange={e=>setWidth(parseInt(e.target.value))} /></div>\n//         <button className=\"btn\" onClick={clearCanvas}>Clear</button>\n//       </div>\n//     </div>\n//   );\n// }","map":{"version":3,"names":[],"sources":["C:/Users/asus/OneDrive/Desktop/whiteboard/client/src/components/DrawingCanvas.js"],"sourcesContent":["// import React, { useEffect, useRef, useState } from 'react';\n\n// export default function DrawingCanvas({ socket, roomId, myColorRef }){\n//   const canvasRef = useRef();\n//   const [isDrawing, setIsDrawing] = useState(false);\n//   const [color, setColor] = useState('#000000');\n//   const [width, setWidth] = useState(2);\n//   const pathRef = useRef([]);\n\n//   useEffect(()=>{\n//     const c = canvasRef.current;\n//     const ctx = c.getContext('2d');\n//     const onLoadCommands = (commands)=>{\n//       commands.forEach(cmd=>{\n//         if(cmd.type === 'stroke'){\n//           drawStroke(ctx, cmd.data, false);\n//         }else if(cmd.type === 'clear'){\n//           ctx.clearRect(0,0,c.width,c.height);\n//         }\n//       });\n//     };\n//     if(socket){\n//       socket.on('load-commands', onLoadCommands);\n//       socket.on('draw-start', ({ payload })=>{\n//         beginRemoteStroke(ctx, payload);\n//       });\n//       socket.on('draw-move', ({ payload })=>{\n//         moveRemoteStroke(ctx, payload);\n//       });\n//       socket.on('draw-end', ({ command })=>{\n//         endRemoteStroke(ctx, command);\n//       });\n//       socket.on('clear-canvas', ()=>{ ctx.clearRect(0,0,c.width,c.height); });\n//     }\n//     return ()=>{\n//       if(socket){\n//         socket.off('load-commands', onLoadCommands);\n//       }\n//     };\n//   }, [socket]);\n\n//   function drawStroke(ctx, data, smooth=true){\n//     ctx.lineJoin = 'round'; ctx.lineCap = 'round';\n//     ctx.strokeStyle = data.color; ctx.lineWidth = data.width;\n//     ctx.beginPath();\n//     const path = data.path || [];\n//     if(path.length===0) return;\n//     ctx.moveTo(path[0].x, path[0].y);\n//     for(let i=1;i<path.length;i++){ ctx.lineTo(path[i].x, path[i].y); }\n//     ctx.stroke();\n//   }\n\n//   function beginRemoteStroke(ctx, payload){ drawStroke(ctx, { color: payload.color, width: payload.width, path: [payload.point] }, false); }\n//   function moveRemoteStroke(ctx, payload){ drawStroke(ctx, { color: payload.color, width: payload.width, path: payload.path }, false); }\n//   function endRemoteStroke(ctx, command){ drawStroke(ctx, command.data, false); }\n\n//   function getPos(e){\n//     const rect = canvasRef.current.getBoundingClientRect();\n//     const clientX = e.touches ? e.touches[0].clientX : e.clientX;\n//     const clientY = e.touches ? e.touches[0].clientY : e.clientY;\n//     return { x: clientX - rect.left, y: clientY - rect.top };\n//   }\n\n//   function start(e){\n//     if(!socket) return;\n//     const p = getPos(e);\n//     setIsDrawing(true);\n//     pathRef.current = [p];\n//     socket.emit('draw-start', { roomId, payload: { point: p, color, width } });\n//   }\n//   function draw(e){\n//     if(!isDrawing || !socket) return;\n//     const p = getPos(e);\n//     pathRef.current.push(p);\n//     socket.emit('draw-move', { roomId, payload: { path: [p], color, width } });\n//     const ctx = canvasRef.current.getContext('2d');\n//     drawStroke(ctx, { color, width, path: pathRef.current });\n//     socket.emit('cursor-move', { roomId, x: p.x, y: p.y });\n//   }\n//   function end(e){\n//     if(!isDrawing || !socket) return;\n//     setIsDrawing(false);\n//     const command = { type:'stroke', data: { path: pathRef.current, color, width }, timestamp: new Date() };\n//     socket.emit('draw-end', { roomId, command });\n//     pathRef.current = [];\n//   }\n\n//   function clearCanvas(){\n//     const ctx = canvasRef.current.getContext('2d');\n//     ctx.clearRect(0,0,canvasRef.current.width, canvasRef.current.height);\n//     if(socket) socket.emit('clear-canvas', { roomId });\n//   }\n\n//   return (\n//     <div style={{width:'100%', height:'100%'}} onMouseLeave={()=>{ if(socket) socket.emit('cursor-move', { roomId, x:-1, y:-1 }); }}>\n//       <canvas ref={canvasRef} style={{width:'100%', height:'100%'}} onMouseDown={start} onMouseMove={draw} onMouseUp={end}\n//         onTouchStart={start} onTouchMove={draw} onTouchEnd={end} />\n//       <div style={{position:'absolute',left:8,top:8,background:'rgba(255,255,255,0.9)',padding:8,borderRadius:6}}>\n//         <div>Color: <input type=\"color\" value={color} onChange={e=>setColor(e.target.value)} /></div>\n//         <div>Width: <input className=\"slider\" type=\"range\" min=\"1\" max=\"12\" value={width} onChange={e=>setWidth(parseInt(e.target.value))} /></div>\n//         <button className=\"btn\" onClick={clearCanvas}>Clear</button>\n//       </div>\n//     </div>\n//   );\n// }\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}